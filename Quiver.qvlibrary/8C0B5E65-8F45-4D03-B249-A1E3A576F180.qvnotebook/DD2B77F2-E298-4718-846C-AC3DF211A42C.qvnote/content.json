{
  "title": "HOC",
  "cells": [
    {
      "type": "text",
      "data": "<br>"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "/* \n * high order component\n * \n */\n\n// 1. props proxy\n// pp_basic\n\n// 将传入原来组件的prop进行一定处理之后在传入组件之中\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n// Props Proxy demonstration\n\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    render() {\n      const props = Object.assign({}, this.props, {\n        user: {\n          name: 'Fran',\n          email: 'franleplant@gmail.com'\n        }\n      })\n      return <WrappedComponent {...props}/>\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  render() {\n    return (\n      <div>\n        <p>\n          As you can see, all original props (date), are being passed through or proxied,\n          and also new props (user) are being added.\n        </p>\n        <pre>{JSON.stringify(this.props)}</pre>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = PPHOC(Example)\n\nReactDOM.render(<EnhancedExample date={(new Date).toISOString()}/>, document.getElementById('root'))\n\n// pp_ref\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n// Props Proxy with ref demonstration\n\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = { name: '' }\n\n      this.updateName = this.updateName.bind(this)\n    }\n\n    updateName(instance) {\n      if (instance.instanceName !== this.state.name)\n        this.setState({name: instance.instanceName})\n    }\n    render() {\n      // Unless you really know what you are doing, dont trigger a state change\n      // inside the render function, this is just for teaching purposes\n      const props = Object.assign({}, this.props, {\n        ref: this.updateName\n      })\n      return (\n        <div>\n          <h2>\n            HOC Component\n          </h2>\n          <p>\n            //The HOC component gets `instanceName` from the WrappedComponent instance via <br/>\n            //`refs` and saves it in it's own state:\n          </p>\n          <pre>{JSON.stringify(this.state, null, 2)}</pre>\n          <WrappedComponent {...props}/>\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  constructor(props) {\n    super(props)\n    this.instanceName = 'han solo'\n  }\n  render() {\n    return (\n      <div>\n        <h2>\n          Wrapped Component\n        </h2>\n        <p>\n          Props\n        </p>\n        <pre>{JSON.stringify(this.props, null, 2)}</pre>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = PPHOC(Example)\n\nReactDOM.render(<EnhancedExample date={(new Date).toISOString()}/>, document.getElementById('root'))\n\n// 3_pp_state\n// Props Proxy and state abstraction demonstration\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = { fields: {} }\n    }\n\n    getField(fieldName) {\n      if (!this.state.fields[fieldName]) {\n        this.state.fields[fieldName] = {\n          value: '',\n          onChange: event => {\n            this.state.fields[fieldName].value = event.target.value\n            this.forceUpdate()\n          }\n        }\n      }\n\n      return {\n        value: this.state.fields[fieldName].value,\n        onChange: this.state.fields[fieldName].onChange\n      }\n    }\n\n    render() {\n      const props = Object.assign({}, this.props, {\n        fields: this.getField.bind(this),\n      })\n      return (\n        <div>\n          <h2>\n            PP HOC\n          </h2>\n          <p>Im a Props Proxy HOC that abstracts controlled inputs</p>\n          <WrappedComponent {...props}/>\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  render() {\n    return (\n      <div>\n        <h2>\n          Wrapped Component\n        </h2>\n        <p>\n          Props\n        </p>\n        <pre>{stringify(this.props)}</pre>\n        <form>\n          <label>Automatically controlled input!</label>\n          <input type=\"email\" {...this.props.fields('email')}/>\n        </form>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = DebuggerHOC(PPHOC(Example))\n\n// 2. inheritance inversion\n// 反转继承\nfunction replacer(key, value) {\n  if (typeof value === 'function') {\n    return `function ${value.name}() {...}`\n  }\n\n  return value\n}\n\nexport function stringify(value) {\n  return JSON.stringify(value, replacer, 2)\n}\n\n// II debug example\n// We are using the Inheritance Inversion technique to display\n// the current state and props of the WrappedComponent (the component you want to debug).\n// This is based on the technique that Mickael Jackson and Ryan Florence recommend\nexport function IIHOC(WrappedComponent) {\n  return class II extends WrappedComponent {\n    render() {\n      return (\n        <div>\n          <h2>\n            HOC Debugger Component\n          </h2>\n          <p>\n            Props\n          </p>\n          <pre>{stringify(this.props)}</pre>\n          <p>\n            State\n          </p>\n          <pre>{stringify(this.state)}</pre>\n          {super.render()}\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      name: 'fran',\n      email: 'franleplant@gmail.com'\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>\n          Wrapped Component\n        </h2>\n        <p>Im a wrapped component</p>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = IIHOC(Example)\n"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "hoc 相当于装饰器的作用 隐式的提供了一些props\n\n// 鼠标追踪器\nconst withMouse  = (Component) => {\n  return class extends React.Compents {\n    state = {x:0 , y:0}\n    handleMouseMove = (e) =>{\n      this.setState({\n        x:e.clientX,\n        y:e.clientY\n      })\n    }\n    \n    render(){\n      return (\n        <div style={{ height:'100%'}} onMouseMove={this.handleMouseMove}>\n          <Component {...this.props} mouse={this.state} />  {/* 注入需要的props*/}\n        </div> \n      )\n    }\n  }\n}\nconst App = React.createClass({\n  render() {\n    const {x,y} = this.props.mouse // 由hoc注入的\n    \n    return (\n      <h1> {x},{y}</h1>  \n    )\n  }\n})\n\nconst AppwithMouse = withMouse(App) // enhance \n\n// 问题\n1. 不够直接 不知道props 从何而来\n2. 命名冲突 两个使用了同名的props的HOC 将遭遇冲突并彼此覆盖\n\n健壮的HOC需要大量的 样板代码？\n\n\n"
    },
    {
      "type": "text",
      "data": "<div><br></div>为什么使用HOC<div>1. 分离关注点</div><div>2. 复用逻辑</div><div><br></div>"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "function mapProps(mapFn) {\n    return function(Comp) {\n        return class extends Component {\n            render() {\n                return <Comp {...mapFn(this.props)}/>\n            }\n        }\n    } \n}\n\nconst ListAdapter = mapProps(mapPropsForNewList)(NewList);\n// 真正的逻辑适配都在HOC中实现\n\n\n// DEMO: how to reuse a async compoent\nimport React, { Component } from 'react';\n\nconst DEFAULT_OPTIONS = {\n  mapStateToProps: undefined,\n  mapLoadingToProps: loading => ({ loading }),\n  mapDataToProps: data => ({ data }),\n  mapErrorToProps: error => ({ error }),\n};\nexport function connectPromise(options) {\n  return (Comp) => {\n    const finalOptions = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n    };\n    const {\n      promiseLoader,\n      mapLoadingToProps,\n      mapStateToProps,\n      mapDataToProps,\n      mapErrorToProps,\n    } = finalOptions;\n\n    class AsyncComponent extends Component {\n      constructor(props) {\n        super(props);\n        this.state = {\n          loading: true,\n          data: undefined,\n          error: undefined,\n        };\n      }\n      componentDidMount() {\n        promiseLoader(this.props)\n          .then(\n            data => this.setState({ data, loading: false }),\n            error => this.setState({ error, loading: false }),\n          );\n      }\n      render() {\n        const { data, error, loading } = this.state;\n\n        const dataProps = data ? mapDataToProps(data) : undefined;\n        const errorProps = error ? mapErrorToProps(error) : undefined;\n\n        return (\n          <Comp\n            {...mapLoadingToProps(loading)}\n            {...dataProps}\n            {...errorProps}\n            {...this.props}\n          />\n        );\n      }\n    }\n\n    return AsyncComponent;\n  };\n}\n\n\nconst UserList = connectPromise({\n    promiseLoader: loadUsers,\n    mapDataToProps: result=> ({list: result.userList})\n})(List); //List can be a pure component\n\nconst BookList = connectPromise({\n    promiseLoader: loadBooks,\n    mapDataToProps: result=> ({list: result.bookList})\n})(List);"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "// connect mock props \n\nconst connetMockProp = mockProps => Comp => {\n    return class extends React.Component {\n        render() {\n            return <Comp {...{ ...this.props, ...mockProps }} />;\n        }\n    };\n};\nexport default connetMockProp(config)(LabelGroup);"
    }
  ]
}