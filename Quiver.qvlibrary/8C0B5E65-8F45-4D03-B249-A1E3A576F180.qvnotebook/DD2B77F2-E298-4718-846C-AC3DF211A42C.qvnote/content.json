{
  "title": "HOC",
  "cells": [
    {
      "type": "text",
      "data": "<br>"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "/* \n * high order component\n * \n */\n\n// 1. props proxy\n// pp_basic\n\n// 将传入原来组件的prop进行一定处理之后在传入组件之中\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n// Props Proxy demonstration\n\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    render() {\n      const props = Object.assign({}, this.props, {\n        user: {\n          name: 'Fran',\n          email: 'franleplant@gmail.com'\n        }\n      })\n      return <WrappedComponent {...props}/>\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  render() {\n    return (\n      <div>\n        <p>\n          As you can see, all original props (date), are being passed through or proxied,\n          and also new props (user) are being added.\n        </p>\n        <pre>{JSON.stringify(this.props, null, 2)}</pre>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = PPHOC(Example)\n\nReactDOM.render(<EnhancedExample date={(new Date).toISOString()}/>, document.getElementById('root'))\n\n// pp_ref\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\n// Props Proxy with ref demonstration\n\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = { name: '' }\n\n      this.updateName = this.updateName.bind(this)\n    }\n\n    updateName(instance) {\n      if (instance.instanceName !== this.state.name)\n        this.setState({name: instance.instanceName})\n    }\n    render() {\n      // Unless you really know what you are doing, dont trigger a state change\n      // inside the render function, this is just for teaching purposes\n      const props = Object.assign({}, this.props, {\n        ref: this.updateName\n      })\n      return (\n        <div>\n          <h2>\n            HOC Component\n          </h2>\n          <p>\n            //The HOC component gets `instanceName` from the WrappedComponent instance via <br/>\n            //`refs` and saves it in it's own state:\n          </p>\n          <pre>{JSON.stringify(this.state, null, 2)}</pre>\n          <WrappedComponent {...props}/>\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  constructor(props) {\n    super(props)\n    this.instanceName = 'han solo'\n  }\n  render() {\n    return (\n      <div>\n        <h2>\n          Wrapped Component\n        </h2>\n        <p>\n          Props\n        </p>\n        <pre>{JSON.stringify(this.props, null, 2)}</pre>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = PPHOC(Example)\n\nReactDOM.render(<EnhancedExample date={(new Date).toISOString()}/>, document.getElementById('root'))\n\n// 3_pp_state\n// Props Proxy and state abstraction demonstration\nfunction PPHOC(WrappedComponent) {\n  return class PP extends React.Component {\n    constructor(props) {\n      super(props)\n      this.state = { fields: {} }\n    }\n\n    getField(fieldName) {\n      if (!this.state.fields[fieldName]) {\n        this.state.fields[fieldName] = {\n          value: '',\n          onChange: event => {\n            this.state.fields[fieldName].value = event.target.value\n            this.forceUpdate()\n          }\n        }\n      }\n\n      return {\n        value: this.state.fields[fieldName].value,\n        onChange: this.state.fields[fieldName].onChange\n      }\n    }\n\n    render() {\n      const props = Object.assign({}, this.props, {\n        fields: this.getField.bind(this),\n      })\n      return (\n        <div>\n          <h2>\n            PP HOC\n          </h2>\n          <p>Im a Props Proxy HOC that abstracts controlled inputs</p>\n          <WrappedComponent {...props}/>\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  render() {\n    return (\n      <div>\n        <h2>\n          Wrapped Component\n        </h2>\n        <p>\n          Props\n        </p>\n        <pre>{stringify(this.props)}</pre>\n        <form>\n          <label>Automatically controlled input!</label>\n          <input type=\"email\" {...this.props.fields('email')}/>\n        </form>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = DebuggerHOC(PPHOC(Example))\n\n// 2. inheritance inversion\n// 反转继承\nfunction replacer(key, value) {\n  if (typeof value === 'function') {\n    return `function ${value.name}() {...}`\n  }\n\n  return value\n}\n\nexport function stringify(value) {\n  return JSON.stringify(value, replacer, 2)\n}\n\n// II debug example\n// We are using the Inheritance Inversion technique to display\n// the current state and props of the WrappedComponent (the component you want to debug).\n// This is based on the technique that Mickael Jackson and Ryan Florence recommend\nexport function IIHOC(WrappedComponent) {\n  return class II extends WrappedComponent {\n    render() {\n      return (\n        <div>\n          <h2>\n            HOC Debugger Component\n          </h2>\n          <p>\n            Props\n          </p>\n          <pre>{stringify(this.props)}</pre>\n          <p>\n            State\n          </p>\n          <pre>{stringify(this.state)}</pre>\n          {super.render()}\n        </div>\n      )\n    }\n  }\n}\n\n\nclass Example extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      name: 'fran',\n      email: 'franleplant@gmail.com'\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>\n          Wrapped Component\n        </h2>\n        <p>Im a wrapped component</p>\n      </div>\n    )\n  }\n}\n\nconst EnhancedExample = IIHOC(Example)\n"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "hoc 相当于装饰器的作用 隐式的提供了一些props\n\n// 鼠标追踪器\nconst withMouse  = (Component) => {\n  return class extends React.Compents {\n    state = {x:0 , y:0}\n    handleMouseMove = (e) =>{\n      this.setState({\n        x:e.clientX,\n        y:e.clientY\n      })\n    }\n    \n    render(){\n      return (\n        <div style={{ height:'100%'}} onMouseMove={this.handleMouseMove}>\n          <Component {...this.props} mouse={this.state} />  {/* 注入需要的props*/}\n        </div> \n      )\n    }\n  }\n}\nconst App = React.createClass({\n  render() {\n    const {x,y} = this.props.mouse // 由hoc注入的\n    \n    return (\n      <h1> {x},{y}</h1>  \n    )\n  }\n})\n\nconst AppwithMouse = withMouse(App) // enhance \n\n// 问题\n1. 不够直接 不知道props 从何而来\n2. 命名冲突 两个使用了同名的props的HOC 将遭遇冲突并彼此覆盖\n\n健壮的HOC需要大量的 样板代码？\n\n\n"
    }
  ]
}