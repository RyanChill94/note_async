{
  "title": "underscore-analysis.js",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "// 判断当前处于什么环境\n// self 用于判断浏览器环境  global 用于判断node 环境\nvar root = typeof(self)=='object' && self.self == self && self || \n           typeof(global)=='object' && global.global && global;\n           \n// 如果处于node环境 将_对象作为模块挂载\nif( typeof exports != 'undefined' && !exports.nodeType){\n    if(typeof module != 'undefined' && !module.exports.nodeType && module.exports){\n        exports = module.exports = _;\n    }\n    exports._ = _;\n}else{\n    root._ = _;\n}\n\n// 松弛绑定\npreviousUnderscore = root._;\n\nvar whateverYouLikeName = _.noConflict();\n\n_.noConflict\n\n\n// 不可靠的undefined\nundefined = 1;\nconsole.log(undefined) // 1\n\n//void 运算符 -> 对指定的表达式\nvoid 0  || void (0)  //undefined\nvoid(alert(1))\n\n// 在IFE中传入undefined\n(function(window,undefined){\n    \n})(window)\n\n\n// 使用迭代\n// 在函数式编程里面 更加推荐使用迭代 而不是循环\n\nvar results = _.map([1,2,3],function(elem){\n    retutn elem * 2 ;\n})\n\n// map 的实现\n\n_.map = -.collection = function (obj, iteratee, content){\n    iteratee = cb(iteratee, content);\n    // 兼容数组和对象取长度的方式    \n    var keys = !isArrayLike(obj) && _.keys(obj);\n    var length = (keys || object).length;\n    \n    for ( var index = 0; index<length; index++) {\n        var currentKey = keys ? keys [index] : index;\n    }\n        \n}\n\n_reduce()\n\n//recreating reduce in js\n\n\n//reduce 实现rest参数\n\nfunction each(collection,cb){\n    if(Array.isArray(collection)){\n        for(var i = 0 ;i<collection.length;i++){\n            cb(collection[i])\n        }\n    }else if(typeof collection == 'object'){\n        for(var  prop in collection){\n            callback(collection[prop])\n        }\n    }\n}\n\nfunction reduce(collection,cb,accumulator){\n    each(collection,function(elem){\n        if(accumlartor == undefined){\n            accumlartor = elem\n        }else{\n            accumlartor = cb(accumulator,elem)\n        }\n    })\n}\n\n[array ,fn ,初始值]\nfunction add(a){   \n    var rest = Array.prototype.slice.call(arguments, 1);   \n    return _.reduce(rest,function(accum, current){     \n        return accum+current;   \n    },a); \n}\nadd(2,3,4,5); // => 14\n\n"
    }
  ]
}