{
  "title": "underscore-analysis.js",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "// 判断当前处于什么环境\n// self 用于判断浏览器环境  global 用于判断node 环境\nvar root = typeof(self)=='object' && self.self == self && self || \n           typeof(global)=='object' && global.global && global;\n           \n// 如果处于node环境 将_对象作为模块挂载\nif( typeof exports != 'undefined' && !exports.nodeType){\n    if(typeof module != 'undefined' && !module.exports.nodeType && module.exports){\n        exports = module.exports = _;\n    }\n    exports._ = _;\n}else{\n    root._ = _;\n}\n\n// 松弛绑定\npreviousUnderscore = root._;\n\nvar whateverYouLikeName = _.noConflict();\n\n_.noConflict\n\n\n// 不可靠的undefined\nundefined = 1;\nconsole.log(undefined) // 1\n\n//void 运算符 -> 对指定的表达式\nvoid 0  || void (0)  //undefined\nvoid(alert(1))\n\n// 在IFE中传入undefined\n(function(window,undefined){\n    \n})(window)\n\n\n// 使用迭代\n// 在函数式编程里面 更加推荐使用迭代 而不是循环\n\nvar results = _.map([1,2,3],function(elem){\n    retutn elem * 2 ;\n})\n\n// map 的实现\n\n_.map = -.collection = function (obj, iteratee, content){\n    iteratee = cb(iteratee, content);\n    // 兼容数组和对象取长度的方式    \n    var keys = !isArrayLike(obj) && _.keys(obj);\n    var length = (keys || object).length;\n    \n    for ( var index = 0; index<length; index++) {\n        var currentKey = keys ? keys [index] : index;\n    }\n        \n}\n"
    }
  ]
}