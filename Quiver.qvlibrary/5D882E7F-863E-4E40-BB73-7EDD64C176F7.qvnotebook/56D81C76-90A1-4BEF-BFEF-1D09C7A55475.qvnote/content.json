{
  "title": "thunk.js",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "// thunk 函数\n// 传值调用 传名调用\n// 编译器的\"传名调用\"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。\n\n// thunk 函数的实现\n// 正常版本的readFile（多参数版本）\nfs.readFile(fileName, callback);\n\n// Thunk版本的readFile（单参数版本）\nvar readFileThunk = Thunk(fileName);\nreadFileThunk(callback);\n\nvar Thunk = function (fileName){\n  return function (callback){\n    return fs.readFile(fileName, callback); \n  };\n};\n\n// 上面代码中，fs 模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。\n\n\n//通用Thunk函数生成方式\nvar Thunk = function(fn){\n  return function (){\n    // 保存thunk函数包裹函数的调用参数\n    var args = Array.prototype.slice.call(arguments);\n    return function (callback){\n    // 回调函数在返回的函数中在次传入cb\n    // 相当于 curry 化\n    // 将参数回传给原函数【接受多个参数的原函数 e.g.readfile】\n      args.push(callback);\n      return fn.apply(this, args);\n    }\n  };\n};\n\n// 调用方式\nvar readFileTunk = Thunk(fs.readFile)\nreadFileThunk(fileA)(cb)\n\n\n// npm 模块\n// thunkify\nvar thunkify = require('thunkify');\nvar fs = require('fs');\n\nvar read = thunkify(fs.readFile);\nread('package.json')(function(err, str){\n  // ...\n});\n\n\n\n// 配合generator函数使用 实现自动化异步处理\n// thunk 函数的在ES6里的generator 出现之前并没有什么作用\n// \n\nvar fs = require('fs');\nvar thunkify = require('thunkify');\nvar readFile = thunkify(fs.readFile);\n\nvar gen = function* (){\n  var r1 = yield readFile('/etc/fstab');\n  console.log(r1.toString());\n  var r2 = yield readFile('/etc/shells');\n  console.log(r2.toString());\n};\n\n// 变量 g 是 Generator 函数的内部指针，表示目前执行到哪一步。next 方法负责将指针移动到下一步，并返回该步的信息（value 属性和 done 属性）。\nvar g = gen();\n\nvar r1 = g.next();\nr1.value(function(err, data){\n  if (err) throw err;\n  var r2 = g.next(data);\n  r2.value(function(err, data){\n    if (err) throw err;\n    g.next(data);\n  });\n});\n\n// run 函数\n\nfunction run(fn) {\n  var gen = fn();\n\n  function next(err, data) {\n    var result = gen.next(data);\n    if (result.done) return;\n    result.value(next);\n  }\n\n  next();\n}\n\nrun(gen);\n\nvar gen = function* (){\n  var f1 = yield readFile('fileA');\n  var f2 = yield readFile('fileB');\n  // ...\n  var fn = yield readFile('fileN');\n};\n\nrun(gen);"
    }
  ]
}