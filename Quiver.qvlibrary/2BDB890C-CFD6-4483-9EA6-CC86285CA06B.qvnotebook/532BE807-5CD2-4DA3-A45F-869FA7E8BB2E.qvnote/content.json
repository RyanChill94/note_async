{
  "title": "git",
  "cells": [
    {
      "type": "markdown",
      "data": "#### tips\ngit add 是将*工作副本*中的文件排除gitignore 之后添加进*缓冲区*\ngit commit 是将缓冲区中生成一次提交记录 重新生成新的HEAD\ngit reset 可以将HEAD 重新指向某一次commit\ngit checkout 可以回到任意一次commit中\n#### git stash\n\n- git stash [ pop | applay ]\n- git list\n- git clear\n\n\n#### add remote branch\n- git remote add pb https://github.com/paulboone/ticgit  对应简写 和完整url\n- git remote -v\n- git fetch pb[remote-name]\n\n#### git push\n- git push [remote-name] [branch-name]\n- 查看这个分支的信息 git remote show origin\n\n#### git fetch\ngit pull = git fetch + merge to local\n\n#### git checkout 切换分支\n\n\n#### git revert\n- git revert HEAD 撤销刚刚的提交\n\n\n#### git reset  [代码回滚] \n1. git log 查看提交历史\n  - git log -n limit 只显示指定数量\n  - git log --online 压缩到一行\n\n\n2. git reset HEAD~2 回退两个版本 \n\n3. git reset --hard HEAD 完全撤销当前的改动\n\n\n4. 已经使用 git add 添加进缓冲区之后 不想使用 使用git reset HEAD 撤销放进缓冲区\n\n\n#### git rebase [区分merge]\n是将分支移到一个新的基提交的过程\nrebase 只不过是将分支从一个提交移到了另一个。但从内部机制来看，Git 是通过在选定的基上创建新提交来完成这件事的——它事实上重写了你的项目历史。理解这一点很重要，尽管分支看上去是一样的，但它包含了全新的提交。\n下面这个🌰同时使用 git rebase 和 git merge 来保持线性的项目历史。这是一个确认你的合并都是快速向前的方法。\n\n# 开始新的功能分支\ngit checkout -b new-feature master\n# 编辑文件\ngit commit -a -m \"Start developing a feature\"\n在 feature 分支开发了一半的时候，我们意识到项目中有一个安全漏洞:\n\n# 基于master分支创建一个快速修复分支\ngit checkout -b hotfix master\n# 编辑文件\ngit commit -a -m \"Fix security hole\"\n# 合并回master\ngit checkout master\ngit merge hotfix\ngit branch -d hotfix\n将 hotfix 分支并回之后 master，我们有了一个分叉的项目历史。我们用 rebase 整合 feature 分支以获得线性的历史，而不是使用普通的 git merge。\n\ngit checkout new-feature\ngit rebase master\n它将 new-feature 分支移到了 master 分支的末端，现在我们可以在 master 上进行标准的快速向前合并了:\n\ngit checkout master\ngit merge new-feature\n\n\n#### 本地分支作死解救指南\n# 编辑了一些文件\n# 新增了一些文件\n# 『糟糕』\n\n# 将跟踪的文件回滚回去\ngit reset --hard\n\n# 移除未跟踪的文件\ngit clean -df"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}