{
  "title": "fully_understand_this",
  "cells": [
    {
      "type": "code",
      "language": "javascript",
      "data": "//this说白了就是找大佬，找拥有当前上下文（context）的对象（context object）。\n//大佬可以分为六层，层数越高权力越大，this只会认最大的。\n\n\n\n第一层：世界尽头\n权力最小的大佬是作为备胎的存在，在普通情况下就是全局，浏览器里就是window；在use strict的情况下就是undefined。\n\n\n\nfunction showThis () {\n\n  console.log(this)\n\n}\n\nfunction showStrictThis () {\n\n  'use strict'\n\n  console.log(this)\n\n}\n\nshowThis() // window\n\nshowStrictThis() // undefined\n\n\n\n第二层：点石成金\n\n\n\n第二层大佬说白了就是找这个函数前面的点.。\n\n\n\n如果用到this的那个函数是属于某个 context object 的，那么这个 context object 绑定到this。\n\n\n\n比如下面的例子，boss是returnThis的 context object ，或者说returnThis属于boss。\n\n\n\nvar boss = {\n\n  name: 'boss',\n\n  returnThis () {\n\n    return this\n\n  }\n\n}\n\nboss.returnThis() === boss // true\n\n\n\n下面这个例子就要小心点咯，能想出答案么？\n\n\n\nvar boss1 = {\n\n  name: 'boss1',\n\n  returnThis () {\n\n    return this\n\n  }\n\n}\n\nvar boss2 = {\n\n  name: 'boss2',\n\n  returnThis () {\n\n    return boss1.returnThis()\n\n  }\n\n}\n\nvar boss3 = {\n\n  name: 'boss3',\n\n  returnThis () {\n\n    var returnThis = boss1.returnThis\n\n    return returnThis()\n\n  }\n\n}\n\nboss1.returnThis() // boss1\n\nboss2.returnThis() // ?\n\nboss3.returnThis() // ?\n\n\n\n答案是boss1和window哦，猜对了吗。\n\n\n\n只要看使用this的那个函数。\n\n\n\n在boss2.returnThis里，使用this的函数是boss1.returnThis，所以this绑定到boss1；\n\n\n\n在boss3.returnThis里，使用this的函数是returnThis，所以this绑定到备胎。\n\n\n\n要想把this绑定到boss2怎么做呢？\n\n\n\nvar boss1 = {\n\n  name: 'boss1',\n\n  returnThis () {\n\n    return this\n\n  }\n\n}\n\nvar boss2 = {\n\n  name: 'boss2',\n\n  returnThis: boss1.returnThis\n\n}\n\nboss2.returnThis() //boss2\n\n\n\n没错，只要让使用this的函数是属于boss2就行。\n\n\n\n第三层：指腹为婚\n\n\n\n第三层大佬是Object.prototype.call和Object.prototype.apply，它们可以通过参数指定this。（注意this是不可以直接赋值的哦，this = 2会报ReferenceError。）\n\n\n\nfunction returnThis () {\n\n  return this\n\n}\n\nvar boss1 = { name: 'boss1' }\n\nreturnThis() // window\n\nreturnThis.call(boss1) // boss1\n\nreturnThis.apply(boss1) // boss1\n\n\n\n第四层：海誓山盟\n\n\n\n第四层大佬是Object.prototype.bind，他不但通过一个新函数来提供永久的绑定，还会覆盖第三层大佬的命令。\n\n\n\nfunction returnThis () {\n\n  return this\n\n}\n\nvar boss1 = { name: 'boss1'}\n\nvar boss1returnThis = returnThis.bind(boss1)\n\nboss1returnThis() // boss1\n\nvar boss2 = { name: 'boss2' }\n\nboss1returnThis.call(boss2) // still boss1\n\n\n\n第五层：内有乾坤\n\n\n\n一个比较容易忽略的会绑定this的地方就是new。当我们new一个函数时，就会自动把this绑定在新对象上，然后再调用这个函数。它会覆盖bind的绑定。\n\n\n\nfunction showThis () {\n\n  console.log(this)\n\n}\n\nshowThis() // window\n\nnew showThis() // showThis\n\nvar boss1 = { name: 'boss1' }\n\nshowThis.call(boss1) // boss1\n\nnew showThis.call(boss1) // TypeError\n\nvar boss1showThis = showThis.bind(boss1)\n\nboss1showThis() // boss1\n\nnew boss1showThis() // showThis\n\n\n\n第六层：军令如山\n\n\n\n最后一个法力无边的大佬就是 ES2015 的箭头函数。箭头函数里的this不再妖艳，被永远封印到当前词法作用域之中，称作 Lexical this ，在代码运行前就可以确定。没有其他大佬可以覆盖。\n\n\n\n这样的好处就是方便让回调函数的this使用当前的作用域，不怕引起混淆。\n\n\n\n所以对于箭头函数，只要看它在哪里创建的就行。\n\n\n\n如果对 V8 实现的词法作用域感兴趣可以看看这里。\n\n\n\nfunction callback (cb) {\n\n  cb()\n\n}\n\ncallback(() => { console.log(this) }) // window\n\nvar boss1 = {\n\n  name: 'boss1',\n\n  callback: callback,\n\n  callback2 () {\n\n    callback(() => { console.log(this) })\n\n  }\n\n}\n\nboss1.callback(() => { console.log(this) }) // still window\n\nboss1.callback2(() => { console.log(this) }) // boss1\n\n\n\n下面这种奇葩的使用方式就需要注意：\n\n\n\nvar returnThis = () => this\n\nreturnThis() // window\n\nnew returnThis() // TypeError\n\nvar boss1 = {\n\n  name: 'boss1',\n\n  returnThis () {\n\n    var func = () => this\n\n    return func()\n\n  }\n\n}\n\nreturnThis.call(boss1) // still window\n\nvar boss1returnThis = returnThis.bind(boss1)\n\nboss1returnThis() // still window\n\nboss1.returnThis() // boss1\n\nvar boss2 = {\n\n  name: 'boss2',\n\n  returnThis: boss1.returnThis\n\n}\n\nboss2.returnThis() // boss2"
    }
  ]
}