{
  "title": "all_about_js_Array_fn.js",
  "cells": [
    {
      "type": "markdown",
      "data": "- Array.of\n  与Array构造器的区别只在于单参数的时候\n  Array(5) => [undefined x 5]\n  Array.of(5) => [5]\n\n- Array.from\n  三个参数 类数组对象，加工函数，上下文\n  ```js\n  var obj = {0: 'a', 1: 'b', 2:'c', length: 3};\n  Array.from(obj, function(value, index){\n    console.log(value, index, this, arguments.length);\n    return value.repeat(3); //必须指定返回值，否则返回undefined\n  }, obj);\n  \n  // ['aaa','bbb','ccc']\n  \n  Array.from(obj, (value) => value.repeat(3));\n  ```\n  可以处理的类数组包括 string、set、Map、arguments\n \n  ```js\n   // String\n  Array.from('abc'); // [\"a\", \"b\", \"c\"]\n  // Set\n  Array.from(new Set(['abc', 'def'])); // [\"abc\", \"def\"]\n  // Map\n  Array.from(new Map([[1, 'abc'], [2, 'def']])); // [[1, 'abc'], [2, 'def']]\n  // 天生的类数组对象arguments\n  function fn(){\n    return Array.from(arguments);\n  }\n  fn(1, 2, 3); // [1, 2, 3]\n  ```\n- Array.isArray\n  判断数据方法\n  - a instanceof Array\n  - a.constructor === Array;\n  - Array.prototype.isPrototypeOf(a);\n  - Object.getPrototypeOf(a) === Array.prototype;\n  - Object.prototype.toString.apply(a) === '[object Array]';\n  \n  *注意*\n  以下测试用例会导致前4种方式全部失效\n  ```js\n  var a = {\n    __proto__: Array.prototype\n  }\n  ```\n\n- 数组推导 for of\n  不是标准规范\n  ```js\n  [for (x of [0, 1, 2]) () => x][0]()\n  ```\n  \n- 非纯函数\n  - pop 类数组如果具有length属性也可以使用\n  - push 实际上是根据length值来决定从哪里开始插入值的\n  - reverse\n  - shift\n  - sort 默认排序是按照unicode进行排序 三种情况（0|1|-1）0->位置不变   -1 ab 1 ba compareFn 返回布尔值结果不可预料\n    按照拼音的先后顺序？ String.localeCompare\n    >在chrome中是优化的 大于10个数 快排序 小于 插入排序\n    【排序的稳定性】快排 -> 不稳定\n  - splice 用新元素替换旧元素来修改数组\n    > splice(start,delCount,item1,item2...)\n  - unshift\n  - copyWithin （ES6）\n    ```js\n    var array = [1,2,3,4,5]; \n    var array2 = array.copyWithin(0,3);\n    console.log(array===array2,array2); // true [4, 5, 3, 4, 5]\n    ```\n  - fill\n    ```js\n    var array = [1,2,3,4,5];\n    var array2 = array.fill(10,0,3);\n    console.log(array===array2,array2); // true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10\n    ```\n- 纯函数\n  - concat 返回值是新数组 不传参可以拷贝数组\n  - join 返回字符串\n  - slice 返回切割的数组对象\n    > slice(start,end)\n      slice 只是对对象进行*浅复制*\n    ```js\n    var array = [{color:\"yellow\"}, 2, 3];\n    var array2 = array.slice(0,1);\n    console.log(array2); // [{color:\"yellow\"}]\n    array[0][\"color\"] = \"blue\";\n    console.log(array2); // [{color:\"bule\"}]\n    ```\n  - toString\n  - toLacaleString\n  - indexOf 严格匹配 相当于===\n    > indexOf(elem,startIndex)\n    fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fomIndex项开始往数组末尾查找，如果length + fromIndex<0 则整个数组都会被查找。\n  - lastIndexOf\n  - includes (ES7)\n    与indexof的区别\n    ```js\n    var array = [NaN]\n    console.log(array.includes(NaN)); // true\n    console.log(arra.indexOf(NaN)>-1); // false\n    ```\n  - toSource [非标准] 返回数组的源代码\n  \n- 遍历方法\n  - forEach(fn, fnContext)\n    无法直接退出循环 只能通过return 来实现类似continue的效果\n  - every\n  - some\n  - filter\n  - reduce\n  - reduceRight\n  - entries 【es6】\n    返回一个迭代器对象\n    ```js\n    var array = ['a','b','c'];\n    var iterator = array.entries();\n    console.log(iterator.next().value); // [0, 'a']\n    console.log(iterator.next().value); // [1, 'b']\n    console.log(iterator.next().value); // [2, 'c']\n    console.log(iterator.next().value); // undefined\n    ```\n  - find & findIndex\n    返回第一个满足条件的元素/下标\n  - keys 返回一个迭代器对象\n  - values\n  - Symbol.iterator 【es6】\n    ```js\n    var array = [\"abc\", \"xyz\"];\n    var iterator = array[Symbol.iterator]();\n    console.log(iterator.next().value); // abc\n    console.log(iterator.next().value); // xyz\n\n    ```\n\n  \n  \n  \n"
    }
  ]
}